[{"title":"Post","url":"/2022/03/06/Post/","content":"<h3 id=\"Notification\"><a href=\"#Notification\" class=\"headerlink\" title=\"Notification\"></a>Notification</h3><p>The blog is coming soon</p>\n"},{"title":"ADS_Note--RB-Tree","url":"/2022/03/07/post001/","content":"<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><h3 id=\"1-RB-Tree’s-properties\"><a href=\"#1-RB-Tree’s-properties\" class=\"headerlink\" title=\"1. RB-Tree’s properties\"></a>1. RB-Tree’s properties</h3><ul>\n<li>A RB-Tree is a BST (Binary Search Tree)</li>\n<li>Every node is either red or black</li>\n<li>The root is black</li>\n<li>Every leaf(NIL) is black</li>\n<li>The children of a red node must be black</li>\n<li><p>For each node $v$, <strong>all descending path from $v$ to leaves contain the same number of black node.</strong> (Note: Also known as black height or $bh(v)$, <strong>excluding $v$</strong>)</p>\n</li>\n<li><p>Corollary: For any subtree T in RB-Tree: $bh(T) \\geq h(T)/2$</p>\n</li>\n</ul>\n<blockquote>\n<p><em>lemma</em>: A RB-Tree T(extended version) with n internal node has height at most $2log(n+1)$</p>\n<p><em>Proof</em>: </p>\n<p>For any $u \\in T$ </p>\n<p>($Tu$ : the subtree rooted at u, size($Tu$) : internal node of $Tu$)</p>\n<p>Will show</p>\n<p>size($Tu$) $\\geq$  $2^{bh(u)}-1$ for any u (inductive hypothesis, will be proved later)</p>\n<p>let u = root of T</p>\n<p>size($T$) $\\geq$ $2^{bh(T)}-1$ $\\geq$ $2^{h(T)/2}-1$ </p>\n<p>therefore we have</p>\n<p>$h(T) \\leq 2log(n+1)$</p>\n<p><em>Inductive hypothesis</em> : Assume that all $Tu$ with height $\\leq$ $k$ , size($Tu$) $\\geq$ $2^{bh(u)}-1$ </p>\n<p>Inductive steps:</p>\n<p>Base case when k = 0(obvious, omitted)</p>\n<p>when height of $Tu$ = $k+1$ </p>\n<p><img src=\"/2022/03/07/post001/pic0.png\" alt=\"inductive\"></p>\n<p>$bh(v_1),bh(v_2) \\geq bh(u)-1$</p>\n<p>size($Tu$) </p>\n<p>= $1+size(Tv_1)+size(Tv_2$</p>\n<p>$\\geq 1+2^{bh(v_1)}-1+2^{bh(v_2)}-1$</p>\n<p>= $2^{bh(v_1)}+2^{bh(v_2)}-1$</p>\n<p>$\\geq 2^{bh(u)-1} + 2^{bh(u)-1}-1$ </p>\n<p>$= 2^{bh(u)}-1$</p>\n</blockquote>\n<hr>\n<h3 id=\"2-RB-Tree-operations\"><a href=\"#2-RB-Tree-operations\" class=\"headerlink\" title=\"2. RB-Tree operations\"></a>2. RB-Tree operations</h3><h4 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h4><p>First we insert as in BST , then mark the new node as red. </p>\n<p>We neglect the symmetric case, only discuss new node $v$ as left child</p>\n<h6 id=\"case-1-sibling-of-u-is-red\"><a href=\"#case-1-sibling-of-u-is-red\" class=\"headerlink\" title=\"case 1 sibling of u is red\"></a><em>case 1</em> sibling of u is red</h6><p>First we do:</p>\n<p><img src=\"/2022/03/07/post001/pic1.png\" alt=\"case 1\"></p>\n<p>Then for different cases: </p>\n<ul>\n<li>If parent of p is black $\\rightarrow$ done</li>\n<li>If p is the root $\\rightarrow$ label p as black, done</li>\n<li>If parent of p is red $\\rightarrow$ violation progress upwards</li>\n</ul>\n<h6 id=\"case-2-sibling-of-u-is-black\"><a href=\"#case-2-sibling-of-u-is-black\" class=\"headerlink\" title=\"case 2 sibling of u is black\"></a><em>case 2</em> sibling of u is black</h6><p><em>case 2.1 v is the left child of u</em></p>\n<p><img src=\"/2022/03/07/post001/pic2.png\" style=\"zoom:67%;\"></p>\n<p><em>case 2.2 v is the right child of u</em></p>\n<p><img src=\"/2022/03/07/post001/pic3.png\" style=\"zoom:67%;\"></p>\n<p>as you can see, it goes to case2.1</p>\n<blockquote>\n<p><strong>Summarization:</strong></p>\n<p><img src=\"/2022/03/07/post001/pic4.png\" style=\"zoom:67%;\"></p>\n<p>Time complexity for insertion : $O(lgn)$</p>\n<p>Max num of rotations : 2</p>\n</blockquote>\n<h4 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h4><p>First we do deletion as in BST , which means the deleted node has at most one child(excluding NIL)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">If the deleted node <span class=\"keyword\">is</span> red:</span><br><span class=\"line\">    done</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> it has a red child:</span><br><span class=\"line\">    mark the child <span class=\"keyword\">as</span> black</span><br><span class=\"line\">    done</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/03/07/post001/pic5.png\" style=\"zoom: 67%;\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> its children are <span class=\"built_in\">all</span> black</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/03/07/post001/pic6.png\" alt=\"case1\"></p>\n<p>now we discuss the double black cases</p>\n<h6 id=\"case-1-the-sibling-of-double-black-is-black\"><a href=\"#case-1-the-sibling-of-double-black-is-black\" class=\"headerlink\" title=\"case 1  the sibling of double black is black\"></a><em>case 1</em>  the sibling of double black is black</h6><p><em>case 1.1 the children of u are all black</em></p>\n<p>First we do</p>\n<p><img src=\"/2022/03/07/post001/pic7.png\" style=\"zoom:67%;\"> </p>\n<p>Then</p>\n<ul>\n<li>If p was red: label p as black</li>\n<li>If p was a root(black): label p as black</li>\n<li>If p was black (non-root): p becomes double black (propagate upwards)</li>\n</ul>\n<p><em>case 1.2 The right child of u is red</em></p>\n<p><img src=\"/2022/03/07/post001/pic8.png\" style=\"zoom:67%;\"></p>\n<p><em>case 1.3 the right child of u is black, the left child of u is red</em></p>\n<p><img src=\"/2022/03/07/post001/pic9.png\" style=\"zoom:67%;\"></p>\n<h6 id=\"case-2-the-sibling-of-double-black-node-is-red\"><a href=\"#case-2-the-sibling-of-double-black-node-is-red\" class=\"headerlink\" title=\"case 2 the sibling of double black node is red\"></a>case 2 the sibling of double black node is red</h6><p><img src=\"/2022/03/07/post001/pica.png\" style=\"zoom:67%;\"></p>\n<p>which goes to case 1</p>\n<blockquote>\n<p><strong>Summarization</strong></p>\n<p><img src=\"/2022/03/07/post001/picb.png\" style=\"zoom:67%;\"></p>\n<p>Time complexity: $O(log(n))$</p>\n<p>Max num of rotations : 3</p>\n</blockquote>\n<hr>\n<h3 id=\"3-Conclusions\"><a href=\"#3-Conclusions\" class=\"headerlink\" title=\"3. Conclusions\"></a>3. Conclusions</h3><h6 id=\"AVL-vs-RB-Tree\"><a href=\"#AVL-vs-RB-Tree\" class=\"headerlink\" title=\"AVL vs. RB-Tree\"></a>AVL vs. RB-Tree</h6><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>AVL</th>\n<th>RB</th>\n<th>performance</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Search</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>AVL is better</td>\n</tr>\n<tr>\n<td>Insertion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>almost the same</td>\n</tr>\n<tr>\n<td>Deletion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>RB is better</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>Although both the AVL and RB-tree has the same worst case boundary, the constant term varies.</p>\n<p>RB-Tree sacrifice the perfect balance for speed up in Deletion process. While AVL may need h(T) rotations ,RB-Tree needs at most 3 times, making RB-Tree widely adopted in industry field.</p>\n</blockquote>\n","categories":["Algorithm"],"tags":["ads"]},{"title":"ADS_Note--B+ Tree","url":"/2022/03/09/post002/","content":"<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><h3 id=\"1-B-Tree’s-properties\"><a href=\"#1-B-Tree’s-properties\" class=\"headerlink\" title=\"1. B+ Tree’s properties\"></a>1. B+ Tree’s properties</h3><ul>\n<li>$h(T)\\approx O(lg_Mn)$</li>\n<li>fanout of the root $\\in [2,M]$ (if the root is not leaf)</li>\n<li>fanout of an internal node(non-root) $\\in [\\lceil M/2\\rceil,M]$</li>\n<li>keys(data pointers, in sorted order) in a leaf(non-root) $\\in [\\lceil M/2\\rceil,M]$ </li>\n<li>all leaves are at the same level</li>\n<li>keys in nodes are in ascending order</li>\n<li>keys $K_i$ in internal nodes  $u$ represent the smallest key in leaves of  the (i+1)th subtree</li>\n<li>If a root is also a leaf : keys in it $\\in [1,M]$</li>\n</ul>\n<blockquote>\n<p>leaves $\\leq \\frac{n}{\\lceil M/2 \\rceil}$ </p>\n<p>height = $O(lg_{\\lceil M/2 \\rceil} \\frac{n}{\\lceil M/2 \\rceil})$ = $O(lg_M N)$</p>\n<p>findkey = $O(lg_2M)*O(lg_M N) = O(lgN)$</p>\n</blockquote>\n<hr>\n<h3 id=\"2-B-Tree-operations\"><a href=\"#2-B-Tree-operations\" class=\"headerlink\" title=\"2. B+-Tree operations\"></a>2. B+-Tree operations</h3><h4 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h4><p>If the insertion break the limitation</p>\n<p>split :</p>\n<p><img src=\"/2022/03/09/post002/image-20220313132549526.png\" alt=\"image-20220313132549526\"></p>\n<p><img src=\"/2022/03/09/post002/image-20220313132645421.png\" alt=\"image-20220313132645421\"></p>\n<blockquote>\n<p>Insertion : $O(M) * O(lg_MN) = O(Mlg_M N)$</p>\n</blockquote>\n<h4 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h4><p>If siblings next to it has more than $\\lceil M/2 \\rceil$ keys :</p>\n<p>​    take 1 from the sibling</p>\n<p>​    update the keys in its ancestors</p>\n<p>If siblings next to it has only $\\lceil M/2 \\rceil$ keys :</p>\n<p>merge:</p>\n<p><img src=\"/2022/03/09/post002/image-20220313133112558.png\" alt=\"image-20220313133112558\"></p>\n<blockquote>\n<p>Deletion : $O(M)*O(lg_M N) = O(Mlg_M N)$</p>\n</blockquote>\n<h3 id=\"3-Conclusions\"><a href=\"#3-Conclusions\" class=\"headerlink\" title=\"3. Conclusions\"></a>3. Conclusions</h3><h6 id=\"AVL-vs-RB-Tree-vs-B-Tree\"><a href=\"#AVL-vs-RB-Tree-vs-B-Tree\" class=\"headerlink\" title=\"AVL vs. RB-Tree vs. B+ Tree\"></a>AVL vs. RB-Tree vs. B+ Tree</h6><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>AVL</th>\n<th>RB</th>\n<th>B+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Search</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>$O(lgN)$</td>\n</tr>\n<tr>\n<td>Insertion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>$O(Mlg_MN)$</td>\n</tr>\n<tr>\n<td>Deletion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>$O(Mlg_MN)$</td>\n</tr>\n</tbody>\n</table>\n</div>\n","categories":["Algorithm"],"tags":["ads"]}]