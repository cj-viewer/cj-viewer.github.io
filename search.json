[{"title":"Post","url":"/2022/03/06/Post/","content":"<h3 id=\"Notification\"><a href=\"#Notification\" class=\"headerlink\" title=\"Notification\"></a>Notification</h3><p>The blog is coming soon</p>\n"},{"title":"ADS_Note--RB-Tree","url":"/2022/03/07/post001/","content":"<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><h3 id=\"1-RB-Tree’s-properties\"><a href=\"#1-RB-Tree’s-properties\" class=\"headerlink\" title=\"1. RB-Tree’s properties\"></a>1. RB-Tree’s properties</h3><ul>\n<li>A RB-Tree is a BST (Binary Search Tree)</li>\n<li>Every node is either red or black</li>\n<li>The root is black</li>\n<li>Every leaf(NIL) is black</li>\n<li>The children of a red node must be black</li>\n<li><p>For each node $v$, <strong>all descending path from $v$ to leaves contain the same number of black node.</strong> (Note: Also known as black height or $bh(v)$, <strong>excluding $v$</strong>)</p>\n</li>\n<li><p>Corollary: For any subtree T in RB-Tree: $bh(T) \\geq h(T)/2$</p>\n</li>\n</ul>\n<blockquote>\n<p><em>lemma</em>: A RB-Tree T(extended version) with n internal node has height at most $2log(n+1)$</p>\n<p><em>Proof</em>: </p>\n<p>For any $u \\in T$ </p>\n<p>($Tu$ : the subtree rooted at u, size($Tu$) : internal node of $Tu$)</p>\n<p>Will show</p>\n<p>size($Tu$) $\\geq$  $2^{bh(u)}-1$ for any u (inductive hypothesis, will be proved later)</p>\n<p>let u = root of T</p>\n<p>size($T$) $\\geq$ $2^{bh(T)}-1$ $\\geq$ $2^{h(T)/2}-1$ </p>\n<p>therefore we have</p>\n<p>$h(T) \\leq 2log(n+1)$</p>\n<p><em>Inductive hypothesis</em> : Assume that all $Tu$ with height $\\leq$ $k$ , size($Tu$) $\\geq$ $2^{bh(u)}-1$ </p>\n<p>Inductive steps:</p>\n<p>Base case when k = 0(obvious, omitted)</p>\n<p>when height of $Tu$ = $k+1$ </p>\n<p><img src=\"/2022/03/07/post001/pic0.png\" alt=\"inductive\"></p>\n<p>$bh(v_1),bh(v_2) \\geq bh(u)-1$</p>\n<p>size($Tu$) </p>\n<p>= $1+size(Tv_1)+size(Tv_2$</p>\n<p>$\\geq 1+2^{bh(v_1)}-1+2^{bh(v_2)}-1$</p>\n<p>= $2^{bh(v_1)}+2^{bh(v_2)}-1$</p>\n<p>$\\geq 2^{bh(u)-1} + 2^{bh(u)-1}-1$ </p>\n<p>$= 2^{bh(u)}-1$</p>\n</blockquote>\n<hr>\n<h3 id=\"2-RB-Tree-operations\"><a href=\"#2-RB-Tree-operations\" class=\"headerlink\" title=\"2. RB-Tree operations\"></a>2. RB-Tree operations</h3><h4 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h4><p>First we insert as in BST , then mark the new node as red. </p>\n<p>We neglect the symmetric case, only discuss new node $v$ as left child</p>\n<h6 id=\"case-1-sibling-of-u-is-red\"><a href=\"#case-1-sibling-of-u-is-red\" class=\"headerlink\" title=\"case 1 sibling of u is red\"></a><em>case 1</em> sibling of u is red</h6><p>First we do:</p>\n<p><img src=\"/2022/03/07/post001/pic1.png\" alt=\"case 1\"></p>\n<p>Then for different cases: </p>\n<ul>\n<li>If parent of p is black $\\rightarrow$ done</li>\n<li>If p is the root $\\rightarrow$ label p as black, done</li>\n<li>If parent of p is red $\\rightarrow$ violation progress upwards</li>\n</ul>\n<h6 id=\"case-2-sibling-of-u-is-black\"><a href=\"#case-2-sibling-of-u-is-black\" class=\"headerlink\" title=\"case 2 sibling of u is black\"></a><em>case 2</em> sibling of u is black</h6><p><em>case 2.1 v is the left child of u</em></p>\n<p><img src=\"/2022/03/07/post001/pic2.png\" style=\"zoom:67%;\"></p>\n<p><em>case 2.2 v is the right child of u</em></p>\n<p><img src=\"/2022/03/07/post001/pic3.png\" style=\"zoom:67%;\"></p>\n<p>as you can see, it goes to case2.1</p>\n<blockquote>\n<p><strong>Summarization:</strong></p>\n<p><img src=\"/2022/03/07/post001/pic4.png\" style=\"zoom:67%;\"></p>\n<p>Time complexity for insertion : $O(lgn)$</p>\n<p>Max num of rotations : 2</p>\n</blockquote>\n<h4 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h4><p>First we do deletion as in BST , which means the deleted node has at most one child(excluding NIL)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">If the deleted node <span class=\"keyword\">is</span> red:</span><br><span class=\"line\">    done</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> it has a red child:</span><br><span class=\"line\">    mark the child <span class=\"keyword\">as</span> black</span><br><span class=\"line\">    done</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/03/07/post001/pic5.png\" style=\"zoom: 67%;\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> its children are <span class=\"built_in\">all</span> black</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/03/07/post001/pic6.png\" alt=\"case1\"></p>\n<p>now we discuss the double black cases</p>\n<h6 id=\"case-1-the-sibling-of-double-black-is-black\"><a href=\"#case-1-the-sibling-of-double-black-is-black\" class=\"headerlink\" title=\"case 1  the sibling of double black is black\"></a><em>case 1</em>  the sibling of double black is black</h6><p><em>case 1.1 the children of u are all black</em></p>\n<p>First we do</p>\n<p><img src=\"/2022/03/07/post001/pic7.png\" style=\"zoom:67%;\"> </p>\n<p>Then</p>\n<ul>\n<li>If p was red: label p as black</li>\n<li>If p was a root(black): label p as black</li>\n<li>If p was black (non-root): p becomes double black (propagate upwards)</li>\n</ul>\n<p><em>case 1.2 The right child of u is red</em></p>\n<p><img src=\"/2022/03/07/post001/pic8.png\" style=\"zoom:67%;\"></p>\n<p><em>case 1.3 the right child of u is black, the left child of u is red</em></p>\n<p><img src=\"/2022/03/07/post001/pic9.png\" style=\"zoom:67%;\"></p>\n<h6 id=\"case-2-the-sibling-of-double-black-node-is-red\"><a href=\"#case-2-the-sibling-of-double-black-node-is-red\" class=\"headerlink\" title=\"case 2 the sibling of double black node is red\"></a>case 2 the sibling of double black node is red</h6><p><img src=\"/2022/03/07/post001/pica.png\" style=\"zoom:67%;\"></p>\n<p>which goes to case 1</p>\n<blockquote>\n<p><strong>Summarization</strong></p>\n<p><img src=\"/2022/03/07/post001/picb.png\" style=\"zoom:67%;\"></p>\n<p>Time complexity: $O(log(n))$</p>\n<p>Max num of rotations : 3</p>\n</blockquote>\n<hr>\n<h3 id=\"3-Conclusions\"><a href=\"#3-Conclusions\" class=\"headerlink\" title=\"3. Conclusions\"></a>3. Conclusions</h3><h6 id=\"AVL-vs-RB-Tree\"><a href=\"#AVL-vs-RB-Tree\" class=\"headerlink\" title=\"AVL vs. RB-Tree\"></a>AVL vs. RB-Tree</h6><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>AVL</th>\n<th>RB</th>\n<th>performance</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Search</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>AVL is better</td>\n</tr>\n<tr>\n<td>Insertion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>almost the same</td>\n</tr>\n<tr>\n<td>Deletion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>RB is better</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>Although both the AVL and RB-tree has the same worst case boundary, the constant term varies.</p>\n<p>RB-Tree sacrifice the perfect balance for speed up in Deletion process. While AVL may need h(T) rotations ,RB-Tree needs at most 3 times, making RB-Tree widely adopted in industry field.</p>\n</blockquote>\n","categories":["Algorithm"],"tags":["ads"]},{"title":"ADS_Note--B+ Tree","url":"/2022/03/09/post002/","content":"<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><h3 id=\"1-B-Tree’s-properties\"><a href=\"#1-B-Tree’s-properties\" class=\"headerlink\" title=\"1. B+ Tree’s properties\"></a>1. B+ Tree’s properties</h3><ul>\n<li>$h(T)\\approx O(lg_Mn)$</li>\n<li>fanout of the root $\\in [2,M]$ (if the root is not leaf)</li>\n<li>fanout of an internal node(non-root) $\\in [\\lceil M/2\\rceil,M]$</li>\n<li>keys(data pointers, in sorted order) in a leaf(non-root) $\\in [\\lceil M/2\\rceil,M]$ </li>\n<li>all leaves are at the same level</li>\n<li>keys in nodes are in ascending order</li>\n<li>keys $K_i$ in internal nodes  $u$ represent the smallest key in leaves of  the (i+1)th subtree</li>\n<li>If a root is also a leaf : keys in it $\\in [1,M]$</li>\n</ul>\n<blockquote>\n<p>leaves $\\leq \\frac{n}{\\lceil M/2 \\rceil}$ </p>\n<p>height = $O(lg_{\\lceil M/2 \\rceil} \\frac{n}{\\lceil M/2 \\rceil})$ = $O(lg_M N)$</p>\n<p>findkey = $O(lg_2M)*O(lg_M N) = O(lgN)$</p>\n</blockquote>\n<hr>\n<h3 id=\"2-B-Tree-operations\"><a href=\"#2-B-Tree-operations\" class=\"headerlink\" title=\"2. B+-Tree operations\"></a>2. B+-Tree operations</h3><h4 id=\"Insertion\"><a href=\"#Insertion\" class=\"headerlink\" title=\"Insertion\"></a>Insertion</h4><p>If the insertion break the limitation</p>\n<p>split :</p>\n<p><img src=\"/2022/03/09/post002/image-20220313132549526.png\" alt=\"image-20220313132549526\"></p>\n<p><img src=\"/2022/03/09/post002/image-20220313132645421.png\" alt=\"image-20220313132645421\"></p>\n<blockquote>\n<p>Insertion : $O(M) * O(lg_MN) = O(Mlg_M N)$</p>\n</blockquote>\n<h4 id=\"Deletion\"><a href=\"#Deletion\" class=\"headerlink\" title=\"Deletion\"></a>Deletion</h4><p>If siblings next to it has more than $\\lceil M/2 \\rceil$ keys :</p>\n<p>​    take 1 from the sibling</p>\n<p>​    update the keys in its ancestors</p>\n<p>If siblings next to it has only $\\lceil M/2 \\rceil$ keys :</p>\n<p>merge:</p>\n<p><img src=\"/2022/03/09/post002/image-20220313133112558.png\" alt=\"image-20220313133112558\"></p>\n<blockquote>\n<p>Deletion : $O(M)*O(lg_M N) = O(Mlg_M N)$</p>\n</blockquote>\n<h3 id=\"3-Conclusions\"><a href=\"#3-Conclusions\" class=\"headerlink\" title=\"3. Conclusions\"></a>3. Conclusions</h3><h6 id=\"AVL-vs-RB-Tree-vs-B-Tree\"><a href=\"#AVL-vs-RB-Tree-vs-B-Tree\" class=\"headerlink\" title=\"AVL vs. RB-Tree vs. B+ Tree\"></a>AVL vs. RB-Tree vs. B+ Tree</h6><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>AVL</th>\n<th>RB</th>\n<th>B+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Search</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>$O(lgN)$</td>\n</tr>\n<tr>\n<td>Insertion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>$O(Mlg_MN)$</td>\n</tr>\n<tr>\n<td>Deletion</td>\n<td>$O(lgn)$</td>\n<td>$O(lgn)$</td>\n<td>$O(Mlg_MN)$</td>\n</tr>\n</tbody>\n</table>\n</div>\n","categories":["Algorithm"],"tags":["ads"]},{"title":"浮点运算","url":"/2022/03/09/post003/","content":"<h2 id><a href=\"#\" class=\"headerlink\" title></a><span id=\"more\"></span></h2><h3 id=\"浮点数算法分析\"><a href=\"#浮点数算法分析\" class=\"headerlink\" title=\"浮点数算法分析\"></a><center>浮点数算法分析</center></h3><h4 id=\"1-IEEE-754标准浮点数：\"><a href=\"#1-IEEE-754标准浮点数：\" class=\"headerlink\" title=\"1. IEEE 754标准浮点数：\"></a>1. IEEE 754标准浮点数：</h4><p>IEEE 754浮点数标准是从逻辑上用三元组{S，T，M}来表示一个数 V 的，即 $V = (-1)^S<em>2^{T-offset}</em>1.M$</p>\n<p>对不同长度的浮点数的存储为分配如图（图片来源与网络）：</p>\n<p><img src=\"/2022/03/09/post003/image-20220407163908680.png\" alt=\"image-20220313132549526\"></p>\n<ul>\n<li><p>S位符号码，确定表示数的正负，从表达式中看出<strong>1</strong>表示负，<strong>0</strong>表示正</p>\n</li>\n<li><p>在 IEEE 754 浮点数标准中，T阶码是用移码表示的，移码的定义：移码 = 真值 + 偏置值</p>\n<p>在 IEEE 754 标准中，移码的偏置值是 2^(n-1)-1，8 位的移码的偏置值为$2^{(8-1)}-1 = 127</p>\n<p>对于阶码全为0和全为1的情况则有不同的处理方式：</p>\n<blockquote>\n<p><strong>当阶码为1，尾数码全为0 ：</strong>表示绝对值最小数</p>\n<p><strong>当阶码全为0，尾数码不全为0 ：</strong>表示非规格化小数，表示比绝对值最小数还要小的数，此时的尾数码隐藏位为0，而非1</p>\n<p><strong>当阶码全为0，尾数码也全为0 ：</strong>表示+/-0</p>\n<p><strong>当阶码全为1，尾数不全为0 ：</strong>表示NAN ，如0/0导致的非法结果</p>\n<p><strong>当阶码全为1，尾数全为0 ：</strong>表示正/负无穷</p>\n</blockquote>\n</li>\n<li><p>对于尾数码，按情况结合表达式在前面加上隐藏位1./0.即可</p>\n</li>\n</ul>\n<h4 id=\"2-运算算法推导\"><a href=\"#2-运算算法推导\" class=\"headerlink\" title=\"2. 运算算法推导\"></a>2. 运算算法推导</h4><ul>\n<li><strong>加法</strong></li>\n</ul>\n<p>加法的算法主要是对相加的两数进行阶数的对其，然后对结果进行规格化，正体如流程图所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TB;</span><br><span class=\"line\">A(开始)--&gt;B(调整尾数使指数相等)</span><br><span class=\"line\">B --&gt; C(尾数相加)</span><br><span class=\"line\">C --&gt; D(规格化)</span><br><span class=\"line\">D --&gt; M(舍入)--&gt;S(规格化结束)--yes--&gt;E&#123;检查溢出&#125;--no--&gt;G(output)</span><br><span class=\"line\">E --yes--&gt; l(异常输出)</span><br><span class=\"line\">S --no--&gt; D</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>本算法在规格化结束后进行溢出检测，结合程序实现方式，这种算法在模拟测试中表示可行，且可以减少检测次数</p>\n<ul>\n<li><strong>减法</strong></li>\n</ul>\n<p>减法即为减数符号取反并进行加法</p>\n<ul>\n<li><strong>乘法</strong></li>\n</ul>\n<p>乘法在步骤上比加法少，对尾数与阶数的处理与加法有些不同，但最终的规格化基本相同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TB;</span><br><span class=\"line\">A(开始)--&gt;B(阶数相加减去offset)--&gt;N(决定符号)</span><br><span class=\"line\">N --&gt; C(尾数相乘)</span><br><span class=\"line\">C --&gt; D(规格化)</span><br><span class=\"line\">D --&gt; M(舍入)--&gt;S(规格化结束)--yes--&gt;E&#123;检查溢出&#125;--no--&gt;G(output)</span><br><span class=\"line\">E --yes--&gt; l(异常输出)</span><br><span class=\"line\">S --no--&gt; D</span><br></pre></td></tr></table></figure>\n<p>在实际实现算法时，尾数相乘尾数回突破32的上线，因此应该先用64位进行扩展，进行右移处理后获得相乘结果</p>\n<ul>\n<li><strong>除法</strong></li>\n</ul>\n<p>除法过程与乘法大致类似，但最开始要讨论特殊情况，如0/0产生NAN，n/0产生无穷等，并且进行尾数除法时使用的是定点数除法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TB;</span><br><span class=\"line\">A(开始)--&gt;X(特殊情况处理)--&gt;B(阶数相加减去offset)--&gt;N(决定符号)</span><br><span class=\"line\">N --&gt; C(尾数定点数除法)</span><br><span class=\"line\">C --&gt; D(规格化)</span><br><span class=\"line\">D --&gt; M(舍入)--&gt;S(规格化结束)--yes--&gt;E&#123;检查溢出&#125;--no--&gt;G(output)</span><br><span class=\"line\">E --yes--&gt; l(异常输出)</span><br><span class=\"line\">S --no--&gt; D</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h4><p>浮点数的处理主要还是对于阶数的处理，以及对于特殊情况的讨论与处理，由于浮点数的尾数限制，计算精度一直是计算几种的难题，相比在硬件算法上进行大的改动，现在的主要趋势还是利用数值分析方法采用软件算法来提高计算结果精确度</p>\n","categories":["Hardware"],"tags":["Computer System"]}]